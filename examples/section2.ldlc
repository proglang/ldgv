-- These are examples from section 2 of the paper "Label Dependent Lambda Calculus and Gradual Typing.pdf" (2021)

type Bool : ~un = {'T, 'F}
type MaybeBool : ~un = {'T, 'F, 'N}
val not(b: Bool) = (case b {'T: 'F, 'F: 'T})

-- This is a LDLC function:
--  f :: Î (x: Bool).Î (y: case x {'T: Int, 'F: Bool}).case x {'T: Int,  'F: Bool}
val f  = ðœ†(x: Bool) ðœ†(y: case x {'T: Int, 'F: Bool}) case x {'T: 17+y, 'F: not y}

-- This is the first GLDLC function:
-- f1 :: Î (x: Bool).Î (y: *).case x {'T: Int, 'F: Bool}

-- This is the second GLDLC function:
-- f2 :: Î (x: *).Î (y: case x {'T: Int, 'F: Bool}).case x {'T: Int, 'F: Bool}

-- This is from the internal CCLDLC representation:
--  f2' :: Î (x: *).Î (y: case (x: * => Bool) {'T: Int, 'F: Bool}).case (x: * => Bool) {'T: Int, 'F: Bool}
val f2'  = ðœ†(x: *) ðœ†(y: case (x: * => Bool) {'T: Int, 'F: Bool}) case (x: * => Bool) {'T: 17+y, 'F: not y}
